(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{95:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return l})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return b})),n.d(t,"default",(function(){return u}));var a=n(3),i=n(7),r=(n(0),n(107)),o=["components"],l={id:"models",title:"Models",sidebar_label:"Models"},s={unversionedId:"models",id:"models",isDocsHomePage:!1,title:"Models",description:"The main way to configure the analysis is through defining models for methods.",source:"@site/documentation/models.md",slug:"/models",permalink:"/docs/models",editUrl:"https://github.com/facebook/mariana-trench/tree/main/documentation/website/documentation/models.md",version:"current",sidebar_label:"Models",sidebar:"someSidebar",previous:{title:"Customize Sources and Sinks",permalink:"/docs/customize_sources_and_sinks"},next:{title:"Configuration",permalink:"/docs/configuration"}},b=[{value:"Models",id:"models",children:[{value:"Method name format",id:"method-name-format",children:[]},{value:"Access path format",id:"access-path-format",children:[]},{value:"Kinds",id:"kinds",children:[]},{value:"Rules",id:"rules",children:[]},{value:"Sources",id:"sources",children:[]},{value:"Sinks",id:"sinks",children:[]},{value:"Return Sinks",id:"return-sinks",children:[]},{value:"Propagation",id:"propagation",children:[]},{value:"Features",id:"features",children:[]},{value:"Sanitizers",id:"sanitizers",children:[]},{value:"Modes",id:"modes",children:[]},{value:"Default model",id:"default-model",children:[]}]},{value:"Generators",id:"generators",children:[{value:"Example",id:"example",children:[]},{value:"Specification",id:"specification",children:[]},{value:"Development",id:"development",children:[]},{value:"Override the default model",id:"override-the-default-model",children:[]}]}],c=function(e){return function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),Object(r.b)("div",t)}},p=c("MultiSourceSinkRule"),d=c("FbModels"),m={toc:b};function u(e){var t=e.components,n=Object(i.a)(e,o);return Object(r.b)("wrapper",Object(a.a)({},m,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"The main way to configure the analysis is through defining models for methods."),Object(r.b)("h2",{id:"models"},"Models"),Object(r.b)("p",null,"A model is an abstract representation of how data flows through a method."),Object(r.b)("p",null,"A model essentialy consists of:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",{parentName:"li",href:"#sources"},"Sources"),": a set of sources that the method produces or receives on parameters;"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",{parentName:"li",href:"#sinks"},"Sinks"),": a set of sinks on the method;"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",{parentName:"li",href:"#propagation"},"Propagation"),": a description of how the method propagates taint coming into it (e.g, the first parameter updates the second, the second parameter updates the return value, etc.);"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",{parentName:"li",href:"#attach-to-sources"},"Attach to Sources"),": a set of features/breadcrumbs to add on an any sources flowing out of the method;"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",{parentName:"li",href:"#attach-to-sinks"},"Attach to Sinks"),": a set of features/breadcrumbs to add on sinks of a given parameter;"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",{parentName:"li",href:"#attach-to-propagations"},"Attach to Propagations"),": a set of features/breadcrumbs to add on propagations for a given parameter or return value;"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",{parentName:"li",href:"#add-features-to-arguments"},"Add Features to Arguments"),": a set of features/breadcrumbs to add on any taint that might flow in a given parameter;"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",{parentName:"li",href:"#sanitizers"},"Sanitizers"),": specifications of taint flows to stop;"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",{parentName:"li",href:"#modes"},"Modes"),": a set of flags describing specific behaviors (see below).")),Object(r.b)("p",null,"Models can be specified in JSON. For example to mark the string parameter to our ",Object(r.b)("inlineCode",{parentName:"p"},"Logger.log")," function as a sink we can specify it as"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-json"},'{\n  "find": "methods",\n  "where": [\n    {\n      "constraint": "signature",\n      "pattern": "Lcom/example/Logger;\\\\.log:\\\\(Ljava/lang/String;\\\\)V"\n    }\n  ],\n  "model": {\n    "sinks" : [\n      {\n        "kind" : "Logging",\n        "port" : "Argument(1)"\n      }\n    ]\n  }\n}\n')),Object(r.b)("p",null,"Note that the naming of methods follow the ",Object(r.b)("a",{parentName:"p",href:"#method-name-format"},"Dalvik's bytecode format"),"."),Object(r.b)("h3",{id:"method-name-format"},"Method name format"),Object(r.b)("p",null,"The format used for method names is:"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"<className>.<methodName>:(<parameterType1><parameterType2>)<returnType>")),Object(r.b)("p",null,"Example: ",Object(r.b)("inlineCode",{parentName:"p"},"Landroidx/fragment/app/Fragment;.startActivity:(Landroid/content/Intent;)V")),Object(r.b)("p",null,"For the parameters and return types use the following table to pick the correct one (please refer to ",Object(r.b)("a",{parentName:"p",href:"https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.3.2-200"},"JVM doc")," for more details)"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"V - void"),Object(r.b)("li",{parentName:"ul"},"Z - boolean"),Object(r.b)("li",{parentName:"ul"},"B - byte"),Object(r.b)("li",{parentName:"ul"},"S - short"),Object(r.b)("li",{parentName:"ul"},"C - char"),Object(r.b)("li",{parentName:"ul"},"I - int"),Object(r.b)("li",{parentName:"ul"},"J - long (64 bits)"),Object(r.b)("li",{parentName:"ul"},"F - float"),Object(r.b)("li",{parentName:"ul"},"D - double (64 bits)")),Object(r.b)("p",null,"Classes take the form ",Object(r.b)("inlineCode",{parentName:"p"},"Lpackage/name/ClassName;")," - where the leading ",Object(r.b)("inlineCode",{parentName:"p"},"L")," indicates that it is a class type, ",Object(r.b)("inlineCode",{parentName:"p"},"package/name/")," is the package that the class is in."),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},Object(r.b)("strong",{parentName:"p"},"NOTE:")," Instance (i.e, non-static) method parameters are indexed starting from 1! The 0th parameter is the ",Object(r.b)("inlineCode",{parentName:"p"},"this")," parameter in dalvik byte-code. For static method parameter, indices start from 0.")),Object(r.b)("h3",{id:"access-path-format"},"Access path format"),Object(r.b)("p",null,"An access path describes the symbolic location of a taint. This is commonly used to indicate where a source or a sink originates from."),Object(r.b)("p",null,"An access path is composed of a root and a path."),Object(r.b)("p",null,"The root is either:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"Return"),", representing the returned value;"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"Argument(x)")," (where ",Object(r.b)("inlineCode",{parentName:"li"},"x")," is an integer), representing the parameter number ",Object(r.b)("inlineCode",{parentName:"li"},"x"),";")),Object(r.b)("p",null,"The path is a (possibly empty) list of field names."),Object(r.b)("p",null,"Access paths are encoded as strings, where elements are separated by a dot: ",Object(r.b)("inlineCode",{parentName:"p"},"<root>.<field1>.<field2>")),Object(r.b)("p",null,"Examples:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"Argument(1).name")," correspond to the field ",Object(r.b)("inlineCode",{parentName:"li"},"name")," of the second parameter;"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"Return.x")," correpsond to the field ",Object(r.b)("inlineCode",{parentName:"li"},"x")," of the returned value;"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"Return")," correspond to the returned value.")),Object(r.b)("h3",{id:"kinds"},"Kinds"),Object(r.b)("p",null,"A source has a ",Object(r.b)("strong",{parentName:"p"},"kind")," that describes its content (e.g, user input, file system, etc).\nA sink also has a ",Object(r.b)("strong",{parentName:"p"},"kind")," that describes the operation the method performs (e.g, execute a command, read a file, etc.).\nKinds can be arbitrary strings (e.g, ",Object(r.b)("inlineCode",{parentName:"p"},"UserInput"),"). We usually avoid whitespaces."),Object(r.b)("h3",{id:"rules"},"Rules"),Object(r.b)("p",null,"A rule describes flows that we want to catch (e.g, user input flowing into command execution).\nA rule is made of a set of source kinds, a set of sink kinds, a name, a code and a description."),Object(r.b)("p",null,"Here is an example of a rule in JSON:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-json"},'{\n  "name": "User input flows into code execution (RCE)",\n  "code": 1,\n  "description": "Values from user-controlled source may eventually flow into code execution",\n  "sources": [\n    "UserInput",\n  ],\n  "sinks": [\n    "CodeExecution",\n  ]\n}\n')),Object(r.b)("p",null,"Rules used by Mariana Trench can be specified with the ",Object(r.b)("inlineCode",{parentName:"p"},"--rules-paths")," argument. The default set of rules that run can be found in ",Object(r.b)("a",{parentName:"p",href:"https://github.com/facebook/mariana-trench/blob/main/configuration/rules.json"},"configuration/rules.json"),"."),Object(r.b)(p,{mdxType:"MultiSourceSinkRule"}),Object(r.b)("h3",{id:"sources"},"Sources"),Object(r.b)("p",null,"Sources describe sources produced or received by a given method. A source can either flow out via the return value or flow via a given parameter. A source has a ",Object(r.b)("strong",{parentName:"p"},"kind")," that describes its content (e.g, user input, file system, etc)."),Object(r.b)("p",null,"Here is an example where the source flows by return value:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-java"},'public static String getPath() {\n    return System.getenv().get("PATH");\n}\n')),Object(r.b)("p",null,"The JSON model for this method could be:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-json"},'{\n  "sources": [\n    {\n      "kind": "UserControlled",\n      "port": "Return"\n    }\n  ]\n}\n')),Object(r.b)("p",null,"Here is an example where the source flows in via an argument:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-java"},"class MyActivity extends Activity {\n  public void onNewIntent(Intent intent) {\n    // intent should be considered a source here.\n  }\n}\n")),Object(r.b)("p",null,"The JSON model for this method could be:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-json"},'{\n  "sources": [\n    {\n      "kind": "UserControlled",\n      "port": "Argument(1)"\n    }\n  ]\n}\n')),Object(r.b)("p",null,"Note that the implicit ",Object(r.b)("inlineCode",{parentName:"p"},"this")," parameter is considered the argument 0."),Object(r.b)("h3",{id:"sinks"},"Sinks"),Object(r.b)("p",null,"Sinks describe dangerous or sensitive methods in the code. A sink has a ",Object(r.b)("strong",{parentName:"p"},"kind")," that represents the type of operation the method does (e.g, command execution, file system operation, etc). A sink must be attached to a given parameter of the method. A method can have multiple sinks."),Object(r.b)("p",null,"Here is an example of a sink:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-java"},"public static String readFile(String path, String extension, int mode) {\n    // Return the content of the file path.extension\n}\n")),Object(r.b)("p",null,"Since ",Object(r.b)("inlineCode",{parentName:"p"},"path")," and ",Object(r.b)("inlineCode",{parentName:"p"},"extension")," can be used to read arbitrary files, we consider them sinks. We do not consider ",Object(r.b)("inlineCode",{parentName:"p"},"mode")," as a sink since we do not care whether the user can control it. The JSON model for this method could be:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-json"},'{\n  "sinks": [\n    {\n      "kind": "FileRead",\n      "port": "Argument(0)"\n    },\n    {\n      "kind": "FileRead",\n      "port": "Argument(1)"\n    }\n  ]\n}\n')),Object(r.b)("h3",{id:"return-sinks"},"Return Sinks"),Object(r.b)("p",null,"Return sinks can be used to describe that a method should not return tainted information. A return sink is just a normal sink with a ",Object(r.b)("inlineCode",{parentName:"p"},"Return")," port."),Object(r.b)("h3",{id:"propagation"},"Propagation"),Object(r.b)("p",null,"Propagations \u2212 also called ",Object(r.b)("strong",{parentName:"p"},"tito")," (Taint In Taint Out) or ",Object(r.b)("strong",{parentName:"p"},"passthrough")," in other tools \u2212 describe how the method propagates taint. A propagation as an ",Object(r.b)("strong",{parentName:"p"},"input")," (where the taint comes from) and an ",Object(r.b)("strong",{parentName:"p"},"output")," (where the taint is moved to)."),Object(r.b)("p",null,"Here is an example of a propagation:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-java"},"public static String concat(String x, String y) {\n  return x + y;\n}\n")),Object(r.b)("p",null,"The return value of the method can be controlled by both parameters, hence it has the propagations ",Object(r.b)("inlineCode",{parentName:"p"},"Argument(0) -> Return")," and ",Object(r.b)("inlineCode",{parentName:"p"},"Argument(1) -> Return"),".  The JSON model for this method could be:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-json"},'{\n  "propagation": [\n    {\n      "input": "Argument(0)",\n      "output": "Return"\n    },\n    {\n      "input": "Argument(1)",\n      "output": "Return"\n    }\n  ]\n}\n')),Object(r.b)("h3",{id:"features"},"Features"),Object(r.b)("p",null,"Features (also called ",Object(r.b)("strong",{parentName:"p"},"breadcrumbs"),") can be used to tag a flow and help filtering issues. A feature describes a property of a flow. A feature can be any arbitrary string."),Object(r.b)("p",null,"For instance, the feature ",Object(r.b)("inlineCode",{parentName:"p"},"via-numerical-operator")," is used to describe that the data flows through a numerical operator such as an addition."),Object(r.b)("p",null,"Features are very useful to filter flows in the SAPP UI. E.g. flows with a cast from string to integer are can sometimes be less important during triaging since controlling an integer is more difficult to exploit than controlling a full string."),Object(r.b)("p",null,"Note that features ",Object(r.b)("strong",{parentName:"p"},"do not stop")," the flow, they just help triaging."),Object(r.b)("h4",{id:"attach-to-sources"},"Attach to Sources"),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Attach to sources")," is used to add a set of ",Object(r.b)("a",{parentName:"p",href:"#features"},"features")," on any sources flowing out of a method through a given parameter or return value."),Object(r.b)("p",null,"For instance, if we want to add the feature ",Object(r.b)("inlineCode",{parentName:"p"},"via-signed")," to all sources flowing out of the given method:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-java"},"public String getSignedCookie();\n")),Object(r.b)("p",null,"We could use the following JSON model:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-json"},'{\n  "attach_to_sources": [\n    {\n      "features": ["via-signed"],\n      "port": "Return"\n    }\n  ]\n}\n')),Object(r.b)("p",null,"Note that this is only useful for sources inferred by the analysis. If you know that ",Object(r.b)("inlineCode",{parentName:"p"},"getSignedCookie")," returns a source of a given kind, you should use a source instead."),Object(r.b)("h4",{id:"attach-to-sinks"},"Attach to Sinks"),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Attach to sinks")," is used to add a set of ",Object(r.b)("a",{parentName:"p",href:"#features"},"features")," on all sinks on the given parameter of a method."),Object(r.b)("p",null,"For instance, if we want to add the feature ",Object(r.b)("inlineCode",{parentName:"p"},"via-user")," on all sinks of the given method:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-java"},"class User {\n  public static User findUser(String username) {\n    // The code here might use SQL, Thrift, or anything. We don't need to know.\n  }\n}\n")),Object(r.b)("p",null,"We could use the following JSON model:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-json"},'{\n  "attach_to_sinks": [\n    {\n      "features": ["via-user"],\n      "port": "Argument(0)"\n    }\n  ]\n}\n')),Object(r.b)("p",null,"Note that this is only useful for sinks inferred by the analysis. If you know that ",Object(r.b)("inlineCode",{parentName:"p"},"findUser")," is a sink of a given kind, you should use a sink instead."),Object(r.b)("h4",{id:"attach-to-propagations"},"Attach to Propagations"),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Attach to propagations")," is used to add a set of ",Object(r.b)("a",{parentName:"p",href:"#features"},"features")," on all propagations from or to a given parameter or return value of a method."),Object(r.b)("p",null,"For instance, if we want to add the feature ",Object(r.b)("inlineCode",{parentName:"p"},"via-concat")," to the propagations of the given method:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-java"},"public static String concat(String x, String y);\n")),Object(r.b)("p",null,"We could use the following JSON model:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-json"},'{\n  "attach_to_propagations": [\n    {\n      "features": ["via-concat"],\n      "port": "Return" // We could also use Argument(0) and Argument(1)\n    }\n  ]\n}\n')),Object(r.b)("p",null,"Note that this is only useful for propagations inferred by the analysis. If you know that ",Object(r.b)("inlineCode",{parentName:"p"},"concat")," has a propagation, you should model it as a propagation directly."),Object(r.b)("h4",{id:"add-features-to-arguments"},"Add Features to Arguments"),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Add features to arguments")," is used to add a set of  ",Object(r.b)("a",{parentName:"p",href:"#features"},"features")," on all sources that ",Object(r.b)("strong",{parentName:"p"},"might")," flow on a given parameter of a method."),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Add features to arguments")," implies ",Object(r.b)("em",{parentName:"p"},"Attach to sources"),", ",Object(r.b)("em",{parentName:"p"},"Attach to sinks")," and ",Object(r.b)("em",{parentName:"p"},"Attach to propagations"),", but it also accounts for possible side effects at call sites."),Object(r.b)("p",null,"For instance:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-java"},'public static void log(String message) {\n  System.out.println(message);\n}\npublic void buyView() {\n  String username = getParameter("username");\n  String product = getParameter("product");\n  log(username);\n  buy(username, product);\n}\n')),Object(r.b)("p",null,"Technically, the ",Object(r.b)("inlineCode",{parentName:"p"},"log")," method doesn't have any source, sink or propagation. We can use ",Object(r.b)("em",{parentName:"p"},"add features to arguments")," to add a feature ",Object(r.b)("inlineCode",{parentName:"p"},"was-logged")," on the flow from ",Object(r.b)("inlineCode",{parentName:"p"},'getParameter("username")')," to ",Object(r.b)("inlineCode",{parentName:"p"},"buy(username, product)"),". We could use the following JSON model for the ",Object(r.b)("inlineCode",{parentName:"p"},"log")," method:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-json"},'{\n  "add_features_to_arguments": [\n    {\n      "features": ["was-logged"],\n      "port": "Argument(0)"\n    }\n  ]\n}\n')),Object(r.b)("h4",{id:"via-type-features"},"Via-type Features"),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Via-type")," features are used to keep track of the type of a callable\u2019s port seen at its callsites during taint flow analysis. They are specified in model generators within the \u201csources\u201d or \u201csinks\u201d field of a model with the \u201cvia_type_of\u201d field. It is mapped to a nonempty list of ports of the method for which we want to create via-type features."),Object(r.b)("p",null,"For example, if we were interested in the specific Activity subclasses with which the method below was called:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-java"},"\npublic void startActivityForResult (Intent intent, int requestCode);\n\n// At some callsite:\nActivitySubclass activitySubclassInstance;\nactivitySubclassInstance.startActivityForResult(intent, requestCode);\n\n")),Object(r.b)("p",null,"we could use the following JSON to specifiy a via-type feature that would materialize as ",Object(r.b)("inlineCode",{parentName:"p"},"via-type:ActivitySubclass"),":"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-json"},'{\n "sinks": [\n   {\n     "port": "Argument(1)",\n     "kind": "SinkKind",\n     "via_type_of": ["Argument(0)"]\n   }\n ]\n}\n')),Object(r.b)("h3",{id:"sanitizers"},"Sanitizers"),Object(r.b)("p",null,"Specifying sanitizers on a model allow us to stop taint flowing through that method. In Mariana Trench, they can be one of three types -"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sources"),": prevent any taint sources from flowing out of the method"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sinks"),": prevent taint from reaching any sinks within the method"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"propagations"),": prevent propagations from being inferred between any two ports of the method.")),Object(r.b)("p",null,"These can be specified in model generators as follows -"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},'"find": "methods",\n"where": ...,\n"model": {\n  "sanitizers": [\n    {"sanitize": "sources"},\n    {"sanitize": "sinks"},\n    {"sanitize": "propagations"},\n  ],\n  ...\n}\n')),Object(r.b)("p",null,"Note, if there are any user-specificed sources, sinks or propagations on the model, sanitizers will not affect them, but it will prevent them from being propagated outward to callsites."),Object(r.b)("h4",{id:"kind-specific-sanitizers"},"Kind-specific Sanitizers"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"sources")," and ",Object(r.b)("inlineCode",{parentName:"p"},"sinks")," sanitizers may include a list of kinds (each with or without a partial_label) to restrict the sanitizer to only sanitizing taint of those kinds. (When unspecified, as in the example above, all taint is sanitized regardless of kind)."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},'"sanitizers": [\n  {"sanitize": "sinks", "kinds": [{"kind": "SinkKindA"}, {"kind": "SinkKindB", "partial_label": "A"}]},\n]\n')),Object(r.b)("h4",{id:"port-specific-sanitizers"},"Port-specific Sanitizers"),Object(r.b)("p",null,"Sanitizers can also specify a specific port (",Object(r.b)("a",{parentName:"p",href:"/docs/models#access-path-format"},"access path")," root) they sanitize (ignoring all the rest). This field ",Object(r.b)("inlineCode",{parentName:"p"},"port")," has a slightly different meaning for each kind of sanitizer -"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sources"),": represents the output port through which sources may not leave the method"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sinks"),": represents the input port through which taint may not trigger any sinks within the model"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"propagations"),": represents the input port through which a propagation to any other port may not be inferred")),Object(r.b)("p",null,"For example if the following method"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"public void someMethod(Object argument1, Object argument2) {\n  toSink(argument1);\n  toSink(argument2);\n}\n")),Object(r.b)("p",null,"had the following sanitizer in its model,"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},'"sanitizers": [\n  {"sanitize": "sinks", "port": "Argument(1)"},\n]\n')),Object(r.b)("p",null,"Then a source flowing into ",Object(r.b)("inlineCode",{parentName:"p"},"argument1")," would be able to cause an issue, but not a source flowing into ",Object(r.b)("inlineCode",{parentName:"p"},"argument2"),"."),Object(r.b)("p",null,"Kind and port specifications may be included in the same sanitizer."),Object(r.b)("h3",{id:"modes"},"Modes"),Object(r.b)("p",null,"Modes are used to describe specific behaviors of methods. Available modes are:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"override-default"),": do not infer modes of methods using heuristics;"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"skip-analysis"),": skip the analysis of the method;"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"add-via-obscure-feature"),": add a feature/breadcrumb called ",Object(r.b)("inlineCode",{parentName:"li"},"via-obscure:<method>")," to sources flowing through this method;"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"taint-in-taint-out"),": propagate the taint on arguments to the return value and into the ",Object(r.b)("inlineCode",{parentName:"li"},"this")," parameter."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"no-join-virtual-overrides"),": do not consider all possible overrides when handling a virtual call to this method.")),Object(r.b)("h3",{id:"default-model"},"Default model"),Object(r.b)("p",null,"A default model is created for each method, except if it is provided by a model generator.\nThe default model has a set of heuristics:"),Object(r.b)("p",null,"If the method has no source code, the model is automatically marked with the following modes:\n",Object(r.b)("inlineCode",{parentName:"p"},"skip-analysis"),", ",Object(r.b)("inlineCode",{parentName:"p"},"add-via-obscure-feature"),", ",Object(r.b)("inlineCode",{parentName:"p"},"taint-in-taint-out"),"."),Object(r.b)("p",null,"If the method has more than 40 overrides, it is marked with the mode ",Object(r.b)("inlineCode",{parentName:"p"},"no-join-virtual-overrides"),"."),Object(r.b)("p",null,"Otherwise, the default model is empty (no sources/sinks/propagations)."),Object(r.b)("h2",{id:"generators"},"Generators"),Object(r.b)("p",null,"Mariana Trench allows for dynamic model specifications. This allows a user to specify models of methods before running the analysis. This is used to specify sources, sinks, propagation and modes."),Object(r.b)("p",null,"Model generators are specified in a generator configuration file, specified by the ",Object(r.b)("inlineCode",{parentName:"p"},"--generator-configuration-path")," parameter. By default, we use ",Object(r.b)("a",{parentName:"p",href:"https://github.com/facebook/mariana-trench/blob/main/configuration/default_generator_config.json"},Object(r.b)("inlineCode",{parentName:"a"},"default_generator_config.json")),"."),Object(r.b)("h3",{id:"example"},"Example"),Object(r.b)("p",null,"Examples of model generators are located in the ",Object(r.b)("a",{parentName:"p",href:"https://github.com/facebook/mariana-trench/tree/main/configuration/model-generators"},Object(r.b)("inlineCode",{parentName:"a"},"configuration/model-generators"))," directory."),Object(r.b)("p",null,"Below is an example of a JSON model generator:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-json"},'{\n  "model_generators": [\n      {\n        "find": "methods",\n        "where": [\n          { "constraint": "name", "pattern": "toString" }\n        ],\n        "model": {\n          "propagation": [\n            {\n              "input": "Argument(0)",\n              "output": "Return"\n            }\n          ]\n        }\n      },\n      {\n        "find": "methods",\n        "where": [\n          {\n            "constraint": "parent",\n            "inner": {\n              "constraint": "extends",\n              "inner": {\n                "constraint": "name", "pattern": "SandcastleCommand"\n              }\n            }\n          },\n          { "constraint": "name", "pattern": "Time" }\n        ],\n        "model": {\n          "sources": [\n            {\n              "kind": "Source",\n              "port": "Return"\n            }\n          ]\n        }\n      },\n      {\n        "find": "methods",\n        "where": [\n          { "constraint": "parent", "inner": { "constraint": "extends", "inner": { "constraint": "name", "pattern": "IEntWithPurposePolicy" }} },\n          { "constraint": "name", "pattern": "gen.*" },\n          { "constraint": "parameter", "idx": 0, "inner": { "constraint": "type", "kind": "extends", "class": "IViewerContext" } },\n          { "constraint": "return", "inner": { "constraint": "extends", "inner": { "constraint": "name", "pattern": "Ent" } } }\n        ],\n        "model": {\n          "modes": ["add-via-obscure-feature"],\n          "sinks": [\n            {\n              "kind": "Sink",\n              "port": "Argument(0)",\n              "features": ["via-gen"]\n            }\n          ]\n        }\n      }\n  ]\n}\n')),Object(r.b)("h3",{id:"specification"},"Specification"),Object(r.b)("p",null,"Each JSON file is a JSON object with a key ",Object(r.b)("inlineCode",{parentName:"p"},"model_generators"),' associated with a list of "rules".'),Object(r.b)("p",null,'Each "rule" defines a "filter" (which uses "constraints" to specify methods for which a "model" should be generated) and a "model". A rule has the following key/values:'),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"find"),": The type of thing to find. We only support ",Object(r.b)("inlineCode",{parentName:"p"},"methods"),";")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"where"),': A list of "constraints". All constraints ',Object(r.b)("strong",{parentName:"p"},"must be satisfied")," by a method in order to generate a model for such method. All the constraints are listed below, grouped by the type of object they are applied to:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("strong",{parentName:"p"},"Method"),":"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"signature"),": Expects an extra property ",Object(r.b)("inlineCode",{parentName:"li"},"pattern")," which is a regex to fully match the full signature (class, method, argument types) of a method;"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"parent"),": Expects an extra property ",Object(r.b)("inlineCode",{parentName:"li"},"inner")," ","[Type]"," which contains a nested constraint to apply to the class holding the method;"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"parameter"),": Expects an extra properties ",Object(r.b)("inlineCode",{parentName:"li"},"idx")," and ",Object(r.b)("inlineCode",{parentName:"li"},"inner")," ","[Type]",", matches when the idx-th parameter of the function or method matches the nested constraint inner;"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"return"),": Expects an extra property ",Object(r.b)("inlineCode",{parentName:"li"},"inner")," ","[Type]"," which contains a nested constraint to apply to the return of the method;"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"is_static | is_constructor | is_native | has_code"),": Accepts an extra property ",Object(r.b)("inlineCode",{parentName:"li"},"value")," which is either ",Object(r.b)("inlineCode",{parentName:"li"},"true")," or ",Object(r.b)("inlineCode",{parentName:"li"},"false"),". By default, ",Object(r.b)("inlineCode",{parentName:"li"},"value")," is considered ",Object(r.b)("inlineCode",{parentName:"li"},"true"),";"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"number_parameters"),": Expects an extra property ",Object(r.b)("inlineCode",{parentName:"li"},"inner")," ","[Integer]"," which contains a nested constraint to apply to the number of parameters (counting the implicit ",Object(r.b)("inlineCode",{parentName:"li"},"this")," parameter);"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"number_overrides"),": Expects an extra property ",Object(r.b)("inlineCode",{parentName:"li"},"inner")," ","[Integer]"," which contains a nested constraint to apply on the number of method overrides."))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("strong",{parentName:"p"},"Type:")),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"extends"),": Expects an extra property ",Object(r.b)("inlineCode",{parentName:"li"},"inner")," ","[Type]"," which contains a nested constraint that must apply to one of the base classes or itself. The optional property ",Object(r.b)("inlineCode",{parentName:"li"},"includes_self")," is a boolean that tells whether the constraint must be applied on the type itself or not;"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"super"),": Expects an extra property ",Object(r.b)("inlineCode",{parentName:"li"},"inner")," ","[Type]"," which contains a nested constraint that must apply on the direct superclass;"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"is_class | is_interface"),": Accepts an extra property ",Object(r.b)("inlineCode",{parentName:"li"},"value")," which is either ",Object(r.b)("inlineCode",{parentName:"li"},"true")," or ",Object(r.b)("inlineCode",{parentName:"li"},"false"),". By default, ",Object(r.b)("inlineCode",{parentName:"li"},"value")," is considered ",Object(r.b)("inlineCode",{parentName:"li"},"true"),";"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("strong",{parentName:"p"},"Method or Type:")),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"name"),": Expects an extra property ",Object(r.b)("inlineCode",{parentName:"li"},"pattern")," which is a regex to fully match the name of the item;"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"has_annotation"),": Expects an extra property ",Object(r.b)("inlineCode",{parentName:"li"},"type")," and an optional property ",Object(r.b)("inlineCode",{parentName:"li"},"pattern"),", respectively a string and a regex fully matching the value of the annotation."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"visibility"),": Expects an extra property ",Object(r.b)("inlineCode",{parentName:"li"},"is")," which is either ",Object(r.b)("inlineCode",{parentName:"li"},"public"),", ",Object(r.b)("inlineCode",{parentName:"li"},"private")," or ",Object(r.b)("inlineCode",{parentName:"li"},"protected"),";"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("strong",{parentName:"p"},"Integer:")),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"< | <= | == | > | >= | !="),": Expects an extra property ",Object(r.b)("inlineCode",{parentName:"li"},"value")," which contains an integer that the input integer is compared with. The input is the left hand side."))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("strong",{parentName:"p"},"Any (Method, Type or Integer):")),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"all_of"),": Expects an extra property ",Object(r.b)("inlineCode",{parentName:"li"},"inners")," ","[Any]"," which is an array holding nested constraints which must all apply;"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"any_of"),": Expects an extra property ",Object(r.b)("inlineCode",{parentName:"li"},"inners")," ","[Any]"," which is an array holding nested constraints where one of them must apply;"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"not"),": Expects an extra property ",Object(r.b)("inlineCode",{parentName:"li"},"inner")," ","[Any]"," which contains a nested constraint that should not apply."))))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"model"),": A model, describing sources/sinks/propagations/etc."),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sources"),"*: A list of sources, i.e a source flowing out of the method via return value or flowing in via an argument. A source has the following key/values:",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"kind"),": The source name;"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"port"),"**: The source access path (e.g, ",Object(r.b)("inlineCode",{parentName:"li"},'"Return"')," or ",Object(r.b)("inlineCode",{parentName:"li"},'"Argument(1)"'),");"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"features"),"*: A list of features/breadcrumbs names;"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"via_type_of"),"*: A list of ports;"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sinks"),"*: A list of sinks, i.e describing that a parameter of the method flows into a sink. A sink has the following key/values:",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"kind"),": The sink name;"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"port"),": The sink access path (e.g, ",Object(r.b)("inlineCode",{parentName:"li"},'"Return"')," or ",Object(r.b)("inlineCode",{parentName:"li"},'"Argument(1)"'),");"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"features"),"*:  A list of features/breadcrumbs names;"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"via_type_of"),"*: A list of ports;"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"propagation"),"*: A list of propagations (also called passthrough) that describe whether a taint on a parameter should result in a taint on the return value or another parameter. A propagation has the following key/values:",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"input"),": The input access path (e.g, ",Object(r.b)("inlineCode",{parentName:"li"},'"Argument(1)"'),");"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"output"),": The output access path (e.g, ",Object(r.b)("inlineCode",{parentName:"li"},'"Return"')," or ",Object(r.b)("inlineCode",{parentName:"li"},'"Argument(2)"'),");"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"features"),"*: A list of features/breadcrumbs names;"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"attach_to_sources"),"*: A list of attach-to-sources that describe that all sources flowing out of the method on the given parameter or return value must have the given features. An attach-to-source has the following key/values:",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"port"),": The access path root (e.g, ",Object(r.b)("inlineCode",{parentName:"li"},'"Return"')," or ",Object(r.b)("inlineCode",{parentName:"li"},'"Argument(1)"'),");"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"features"),": A list of features/breadcrumb names;"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"attach_to_sinks"),"*: A list of attach-to-sinks that describe that all sources flowing in the method on the given parameter must have the given features. An attach-to-sink has the following key/values:",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"port"),": The access path root (e.g, ",Object(r.b)("inlineCode",{parentName:"li"},'"Argument(1)"'),");"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"features"),": A list of features/breadcrumb names;"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"attach_to_propagations"),"*: A list of attach-to-propagations that describe that inferred propagations of sources flowing in or out of a given parameter or return value  must have the given features. An attach-to-propagation has the following key/values:",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"port"),": The access path root (e.g, ",Object(r.b)("inlineCode",{parentName:"li"},'"Return"')," or ",Object(r.b)("inlineCode",{parentName:"li"},'"Argument(1)"'),");"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"features"),": A list of features/breadcrumb names;"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"add_features_to_parameters"),"*: A list of add-features-to-parameters that describe that flows that might flow on the given parameter must have the given features. An add-features-to-parameter has the following key/values:",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"port"),": The access path root (e.g, ",Object(r.b)("inlineCode",{parentName:"li"},'"Argument(1)"'),");"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"features"),": A list of features/breadcrumb names;"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"modes"),"*: A list of mode names that describe specific behaviors of a method;"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"for_all_parameters"),": Generate sources/sinks/propagations/attach",Object(r.b)("em",{parentName:"li"},"to"),"* for all parameters of a method that satisfy some constraints. It accepts the following key/values:",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"variable"),": A symbolic name for the parameter;"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"where"),": An optional list of constraints on the type of the parameter;"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"sources | sinks | propagation"),': Same as under "model", but we accept the variable name as a parameter number.'))))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"verbosity"),"*: A logging level, to help debugging. 1 is the most verbose, 5 is the least. The default verbosity level is 5."))),Object(r.b)("p",null,"In the above bullets,"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"*")," denotes optional key/value."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"**")," denotes optional key/value. Default is ",Object(r.b)("inlineCode",{parentName:"li"},'"Return"'),".")),Object(r.b)("p",null,"Note, the implicit ",Object(r.b)("inlineCode",{parentName:"p"},"this")," parameter for methods has the parameter number 0."),Object(r.b)("h3",{id:"development"},"Development"),Object(r.b)("h4",{id:"when-sources-or-sinks-dont-appear-in-results"},"When Sources or Sinks don't appear in Results"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"This could be because your model generator did not find any method matching your query. You can use the ",Object(r.b)("inlineCode",{parentName:"p"},'"verbosity": 1')," option in your model generator to check if it matched any method. For instance:"),Object(r.b)("pre",{parentName:"li"},Object(r.b)("code",{parentName:"pre",className:"language-json"},'{\n  "model_generators":. [\n    {\n      "find": "methods",\n      "where": /* ... */,\n      "model": {\n        /* ... */\n      },\n      "verbosity": 1\n    }\n  ]\n}\n')),Object(r.b)("p",{parentName:"li"},"When running mariana trench, this should print:"),Object(r.b)("pre",{parentName:"li"},Object(r.b)("code",{parentName:"pre"},"INFO Method `...` satisfies all constraints in json model generator ...\n"))),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"Make sure that your model generator is actually running. You can use the ",Object(r.b)("inlineCode",{parentName:"p"},"--verbosity 2")," option to check that. Make sure your model generator is specified in ",Object(r.b)("inlineCode",{parentName:"p"},"configuration/default_generator_config.json"),".")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"You can also check the output models.\nUse ",Object(r.b)("inlineCode",{parentName:"p"},"grep SourceKind models@*")," to see if your source or sink kind exists.\nUse ",Object(r.b)("inlineCode",{parentName:"p"},"grep 'Lcom/example/<class-name>;.<method-name>:' models@*")," to see if a given method exists in the app."))),Object(r.b)("h3",{id:"override-the-default-model"},"Override the default model"),Object(r.b)("p",null,"Mariana trench generates a default model for each method (",Object(r.b)("a",{parentName:"p",href:"/docs/models#default-model"},"see above"),") using a set of heuristics."),Object(r.b)("p",null,"Users can use a ",Object(r.b)("a",{parentName:"p",href:"/docs/models#generators"},"model generator")," to override the default behavior. This can be done to:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Stop a method from propagating the taint (e.g, ",Object(r.b)("inlineCode",{parentName:"li"},"escape")," functions);"),Object(r.b)("li",{parentName:"ul"},"Skip the analysis of a slow method;"),Object(r.b)("li",{parentName:"ul"},"Avoid considering all overrides when handling a virtual method call;"),Object(r.b)("li",{parentName:"ul"},"Etc..")),Object(r.b)("p",null,"In order to do that, one needs to create a model using the ",Object(r.b)("inlineCode",{parentName:"p"},"override-default")," mode, with any additional modes:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"auto model = Model(method, /* modes */ Model::Mode::OverrideDefault | Model::Mode::NoJoinVirtualOverrides);\n")),Object(r.b)("p",null,"NOTE: If you get the error ",Object(r.b)("inlineCode",{parentName:"p"},"Attempting to analyze method <name> with no code!"),", it probably means that you forgot to mark the method with ",Object(r.b)("inlineCode",{parentName:"p"},"Model::Mode::SkipAnalysis")),Object(r.b)(d,{mdxType:"FbModels"}))}u.isMDXComponent=!0}}]);