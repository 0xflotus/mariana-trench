(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{93:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return l})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return c})),n.d(t,"default",(function(){return d}));var a,i=n(3),r=n(7),o=(n(0),n(105)),l={id:"models",title:"Models",sidebar_label:"Models"},s={unversionedId:"models",id:"models",isDocsHomePage:!1,title:"Models",description:"The main way to configure the analysis is through defining models for methods.",source:"@site/documentation/models.md",slug:"/models",permalink:"/docs/models",version:"current",sidebar_label:"Models",sidebar:"someSidebar",previous:{title:"Configuration",permalink:"/docs/configuration"},next:{title:"Running on 3rd-Party Apps",permalink:"/docs/running-on-3rd-party-apps"}},c=[{value:"Models",id:"models",children:[{value:"Method name format",id:"method-name-format",children:[]},{value:"Access path format",id:"access-path-format",children:[]},{value:"Kinds",id:"kinds",children:[]},{value:"Rules",id:"rules",children:[]},{value:"Sources",id:"sources",children:[]},{value:"Sinks",id:"sinks",children:[]},{value:"Return Sinks",id:"return-sinks",children:[]},{value:"Propagation",id:"propagation",children:[]},{value:"Features",id:"features",children:[]},{value:"Modes",id:"modes",children:[]},{value:"Default model",id:"default-model",children:[]}]},{value:"Generators",id:"generators",children:[{value:"Example",id:"example",children:[]},{value:"Specification",id:"specification",children:[]},{value:"Development",id:"development",children:[]}]}],b=(a="FbModels",function(e){return console.warn("Component "+a+" was not imported, exported, or provided by MDXProvider as global scope"),Object(o.b)("div",e)}),p={toc:c};function d(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(i.a)({},p,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"The main way to configure the analysis is through defining models for methods."),Object(o.b)("h2",{id:"models"},"Models"),Object(o.b)("p",null,"A model is an abstract representation of how data flows through a method."),Object(o.b)("p",null,"A model essentialy consists of:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(i.a)({parentName:"li"},{href:"#sources"}),"Sources"),": a set of sources that the method produces or receives on parameters;"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(i.a)({parentName:"li"},{href:"#sinks"}),"Sinks"),": a set of sinks on the method;"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(i.a)({parentName:"li"},{href:"#propagation"}),"Propagation"),": a description of how the method propagates taint coming into it (e.g, the first parameter updates the second, the second parameter updates the return value, etc.);"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(i.a)({parentName:"li"},{href:"#attach-to-sources"}),"Attach to Sources"),": a set of features/breadcrumbs to add on an any sources flowing out of the method;"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(i.a)({parentName:"li"},{href:"#attach-to-sinks"}),"Attach to Sinks"),": a set of features/breadcrumbs to add on sinks of a given parameter;"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(i.a)({parentName:"li"},{href:"#attach-to-propagations"}),"Attach to Propagations"),": a set of features/breadcrumbs to add on propagations for a given parameter or return value;"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(i.a)({parentName:"li"},{href:"#add-features-to-arguments"}),"Add Features to Arguments"),": a set of features/breadcrumbs to add on any taint that might flow in a given parameter;"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(i.a)({parentName:"li"},{href:"#modes"}),"Modes"),": a set of flags describing specific behaviors (see below).")),Object(o.b)("p",null,"Models can be specified in JSON. For example to mark the string parameter to our ",Object(o.b)("inlineCode",{parentName:"p"},"Logger.log")," function as a sink we can specify it as"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-json"}),'{\n  "method" : "Lcom/example/Logger;.log:(Ljava/lang/String;)V",\n  "sinks" : [\n    {\n      "kind" : "Logging",\n      "port" : "Argument(1)"\n    }\n  ]\n}\n')),Object(o.b)("p",null,"Note that the naming of methods follow the ",Object(o.b)("a",Object(i.a)({parentName:"p"},{href:"#method-name-format"}),"Dalvik's bytecode format"),"."),Object(o.b)("h3",{id:"method-name-format"},"Method name format"),Object(o.b)("p",null,"The format used for method names is:"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"<className>.<methodName>:(<parameterType1><parameterType2>)<returnType>")),Object(o.b)("p",null,"Example: ",Object(o.b)("inlineCode",{parentName:"p"},"Landroidx/fragment/app/Fragment;.startActivity:(Landroid/content/Intent;)V")),Object(o.b)("p",null,"For the parameters and return types use the following table to pick the correct one (please refer to ",Object(o.b)("a",Object(i.a)({parentName:"p"},{href:"https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.3.2-200"}),"JVM doc")," for more details)"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"V - void"),Object(o.b)("li",{parentName:"ul"},"Z - boolean"),Object(o.b)("li",{parentName:"ul"},"B - byte"),Object(o.b)("li",{parentName:"ul"},"S - short"),Object(o.b)("li",{parentName:"ul"},"C - char"),Object(o.b)("li",{parentName:"ul"},"I - int"),Object(o.b)("li",{parentName:"ul"},"J - long (64 bits)"),Object(o.b)("li",{parentName:"ul"},"F - float"),Object(o.b)("li",{parentName:"ul"},"D - double (64 bits)")),Object(o.b)("p",null,"Classes take the form ",Object(o.b)("inlineCode",{parentName:"p"},"Lpackage/name/ClassName;")," - where the leading ",Object(o.b)("inlineCode",{parentName:"p"},"L")," indicates that it is a class type, ",Object(o.b)("inlineCode",{parentName:"p"},"package/name/")," is the package that the class is in."),Object(o.b)("p",null,"Note, instance (i.e, non-static) method parameters are indexed starting from 1! The 0th parameter is the ",Object(o.b)("inlineCode",{parentName:"p"},"this")," parameter in dalvik byte-code. For static method parameter, indices start from 0."),Object(o.b)("h3",{id:"access-path-format"},"Access path format"),Object(o.b)("p",null,"An access path describes the symbolic location of a taint. This is commonly used to indicate where a source or a sink originates from."),Object(o.b)("p",null,"An access path is composed of a root and a path."),Object(o.b)("p",null,"The root is either:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"Return"),", representing the returned value;"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"Argument(x)")," (where ",Object(o.b)("inlineCode",{parentName:"li"},"x")," is an integer), representing the parameter number ",Object(o.b)("inlineCode",{parentName:"li"},"x"),";")),Object(o.b)("p",null,"The path is a (possibly empty) list of field names."),Object(o.b)("p",null,"Access paths are encoded as strings, where elements are separated by a dot: ",Object(o.b)("inlineCode",{parentName:"p"},"<root>.<field1>.<field2>")),Object(o.b)("p",null,"Examples:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"Argument(1).name")," correspond to the field ",Object(o.b)("inlineCode",{parentName:"li"},"name")," of the second parameter;"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"Return.x")," correpsond to the field ",Object(o.b)("inlineCode",{parentName:"li"},"x")," of the returned value;"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"Return")," correspond to the returned value.")),Object(o.b)("h3",{id:"kinds"},"Kinds"),Object(o.b)("p",null,"A source has a ",Object(o.b)("strong",{parentName:"p"},"kind")," that describes its content (e.g, user input, file system, etc).\nA sink also has a ",Object(o.b)("strong",{parentName:"p"},"kind")," that describes the operation the method performs (e.g, execute a command, read a file, etc.).\nKinds can be arbitrary strings (e.g, ",Object(o.b)("inlineCode",{parentName:"p"},"UserInput"),"). We usually avoid whitespaces."),Object(o.b)("h3",{id:"rules"},"Rules"),Object(o.b)("p",null,"A rule describes flows that we want to catch (e.g, user input flowing into command execution).\nA rule is made of a set of source kinds, a set of sink kinds, a name, a code and a description."),Object(o.b)("p",null,"Here is an example of a rule in JSON:"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-json"}),'{\n  "name": "User input flows into code execution (RCE)",\n  "code": 1,\n  "description": "Values from user-controlled source may eventually flow into code execution",\n  "sources": [\n    "UserInput",\n  ],\n  "sinks": [\n    "CodeExecution",\n  ]\n}\n')),Object(o.b)("p",null,"Rules used by Mariana Trench can be specified with the ",Object(o.b)("inlineCode",{parentName:"p"},"--rules-paths")," argument. The default set of rules that run can be found in ",Object(o.b)("a",Object(i.a)({parentName:"p"},{href:"https://github.com/facebook/mariana-trench/blob/master/configuration/rules.json"}),"configuration/rules.json"),"."),Object(o.b)("h3",{id:"sources"},"Sources"),Object(o.b)("p",null,"Sources describe sources produced or received by a given method. A source can either flow out via the return value or flow via a given parameter. A source has a ",Object(o.b)("strong",{parentName:"p"},"kind")," that describes its content (e.g, user input, file system, etc)."),Object(o.b)("p",null,"Here is an example where the source flows by return value:"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),'public static String getPath() {\n    return System.getenv().get("PATH");\n}\n')),Object(o.b)("p",null,"The JSON model for this method could be:"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-json"}),'{\n  "sources": [\n    {\n      "kind": "UserControlled",\n      "port": "Return"\n    }\n  ]\n}\n')),Object(o.b)("p",null,"Here is an example where the source flows in via an argument:"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),"class MyActivity extends Activity {\n  public void onNewIntent(Intent intent) {\n    // intent should be considered a source here.\n  }\n}\n")),Object(o.b)("p",null,"The JSON model for this method could be:"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-json"}),'{\n  "sources": [\n    {\n      "kind": "UserControlled",\n      "port": "Argument(1)"\n    }\n  ]\n}\n')),Object(o.b)("p",null,"Note that the implicit ",Object(o.b)("inlineCode",{parentName:"p"},"this")," parameter is considered the argument 0."),Object(o.b)("h3",{id:"sinks"},"Sinks"),Object(o.b)("p",null,"Sinks describe dangerous or sensitive methods in the code. A sink has a ",Object(o.b)("strong",{parentName:"p"},"kind")," that represents the type of operation the method does (e.g, command execution, file system operation, etc). A sink must be attached to a given parameter of the method. A method can have multiple sinks."),Object(o.b)("p",null,"Here is an example of a sink:"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),"public static String readFile(String path, String extension, int mode) {\n    // Return the content of the file path.extension\n}\n")),Object(o.b)("p",null,"Since ",Object(o.b)("inlineCode",{parentName:"p"},"path")," and ",Object(o.b)("inlineCode",{parentName:"p"},"extension")," can be used to read arbitrary files, we consider them sinks. We do not consider ",Object(o.b)("inlineCode",{parentName:"p"},"mode")," as a sink since we do not care whether the user can control it. The JSON model for this method could be:"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-json"}),'{\n  "sinks": [\n    {\n      "kind": "FileRead",\n      "port": "Argument(0)"\n    },\n    {\n      "kind": "FileRead",\n      "port": "Argument(1)"\n    }\n  ]\n}\n')),Object(o.b)("h3",{id:"return-sinks"},"Return Sinks"),Object(o.b)("p",null,"Return sinks can be used to describe that a method should not return tainted information. A return sink is just a normal sink with a ",Object(o.b)("inlineCode",{parentName:"p"},"Return")," port."),Object(o.b)("h3",{id:"propagation"},"Propagation"),Object(o.b)("p",null,"Propagations \u2212 also called ",Object(o.b)("strong",{parentName:"p"},"tito")," (Taint In Taint Out) or ",Object(o.b)("strong",{parentName:"p"},"passthrough")," in other tools \u2212 describe how the method propagates taint. A propagation as an ",Object(o.b)("strong",{parentName:"p"},"input")," (where the taint comes from) and an ",Object(o.b)("strong",{parentName:"p"},"output")," (where the taint is moved to)."),Object(o.b)("p",null,"Here is an example of a propagation:"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),"public static String concat(String x, String y) {\n  return x + y;\n}\n")),Object(o.b)("p",null,"The return value of the method can be controlled by both parameters, hence it has the propagations ",Object(o.b)("inlineCode",{parentName:"p"},"Argument(0) -> Return")," and ",Object(o.b)("inlineCode",{parentName:"p"},"Argument(1) -> Return"),".  The JSON model for this method could be:"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-json"}),'{\n  "propagation": [\n    {\n      "input": "Argument(0)",\n      "output": "Return"\n    },\n    {\n      "input": "Argument(1)",\n      "output": "Return"\n    }\n  ]\n}\n')),Object(o.b)("h3",{id:"features"},"Features"),Object(o.b)("p",null,"Features (also called ",Object(o.b)("strong",{parentName:"p"},"breadcrumbs"),") can be used to tag a flow and help filtering issues. A feature describes a property of a flow. A feature can be any arbitrary string."),Object(o.b)("p",null,"For instance, the feature ",Object(o.b)("inlineCode",{parentName:"p"},"via-numerical-operator")," is used to describe that the data flows through a numerical operator such as an addition."),Object(o.b)("p",null,"Features are very useful to filter flows in the SAPP UI. E.g. flows with a cast from string to integer are can sometimes be less important during triaging since controlling an integer is more difficult to exploit than controlling a full string."),Object(o.b)("p",null,"Note that features ",Object(o.b)("strong",{parentName:"p"},"do not stop")," the flow, they just help triaging."),Object(o.b)("h4",{id:"attach-to-sources"},"Attach to Sources"),Object(o.b)("p",null,Object(o.b)("em",{parentName:"p"},"Attach to sources")," is used to add a set of ",Object(o.b)("a",Object(i.a)({parentName:"p"},{href:"#features"}),"features")," on any sources flowing out of a method through a given parameter or return value."),Object(o.b)("p",null,"For instance, if we want to add the feature ",Object(o.b)("inlineCode",{parentName:"p"},"via-signed")," to all sources flowing out of the given method:"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),"public String getSignedCookie();\n")),Object(o.b)("p",null,"We could use the following JSON model:"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-json"}),'{\n  "attach_to_sources": [\n    {\n      "features": ["via-signed"],\n      "port": "Return"\n    }\n  ]\n}\n')),Object(o.b)("p",null,"Note that this is only useful for sources inferred by the analysis. If you know that ",Object(o.b)("inlineCode",{parentName:"p"},"getSignedCookie")," returns a source of a given kind, you should use a source instead."),Object(o.b)("h4",{id:"attach-to-sinks"},"Attach to Sinks"),Object(o.b)("p",null,Object(o.b)("em",{parentName:"p"},"Attach to sinks")," is used to add a set of ",Object(o.b)("a",Object(i.a)({parentName:"p"},{href:"#features"}),"features")," on all sinks on the given parameter of a method."),Object(o.b)("p",null,"For instance, if we want to add the feature ",Object(o.b)("inlineCode",{parentName:"p"},"via-user")," on all sinks of the given method:"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),"class User {\n  public static User findUser(String username) {\n    // The code here might use SQL, Thrift, or anything. We don't need to know.\n  }\n}\n")),Object(o.b)("p",null,"We could use the following JSON model:"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-json"}),'{\n  "attach_to_sinks": [\n    {\n      "features": ["via-user"],\n      "port": "Argument(0)"\n    }\n  ]\n}\n')),Object(o.b)("p",null,"Note that this is only useful for sinks inferred by the analysis. If you know that ",Object(o.b)("inlineCode",{parentName:"p"},"findUser")," is a sink of a given kind, you should use a sink instead."),Object(o.b)("h4",{id:"attach-to-propagations"},"Attach to Propagations"),Object(o.b)("p",null,Object(o.b)("em",{parentName:"p"},"Attach to propagations")," is used to add a set of ",Object(o.b)("a",Object(i.a)({parentName:"p"},{href:"#features"}),"features")," on all propagations from or to a given parameter or return value of a method."),Object(o.b)("p",null,"For instance, if we want to add the feature ",Object(o.b)("inlineCode",{parentName:"p"},"via-concat")," to the propagations of the given method:"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),"public static String concat(String x, String y);\n")),Object(o.b)("p",null,"We could use the following JSON model:"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-json"}),'{\n  "attach_to_propagations": [\n    {\n      "features": ["via-concat"],\n      "port": "Return" // We could also use Argument(0) and Argument(1)\n    }\n  ]\n}\n')),Object(o.b)("p",null,"Note that this is only useful for propagations inferred by the analysis. If you know that ",Object(o.b)("inlineCode",{parentName:"p"},"concat")," has a propagation, you should model it as a propagation directly."),Object(o.b)("h4",{id:"add-features-to-arguments"},"Add Features to Arguments"),Object(o.b)("p",null,Object(o.b)("em",{parentName:"p"},"Add features to arguments")," is used to add a set of  ",Object(o.b)("a",Object(i.a)({parentName:"p"},{href:"#features"}),"features")," on all sources that ",Object(o.b)("strong",{parentName:"p"},"might")," flow on a given parameter of a method."),Object(o.b)("p",null,Object(o.b)("em",{parentName:"p"},"Add features to arguments")," implies ",Object(o.b)("em",{parentName:"p"},"Attach to sources"),", ",Object(o.b)("em",{parentName:"p"},"Attach to sinks")," and ",Object(o.b)("em",{parentName:"p"},"Attach to propagations"),", but it also accounts for possible side effects at call sites."),Object(o.b)("p",null,"For instance:"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),'public static void log(String message) {\n  System.out.println(message);\n}\npublic void buyView() {\n  String username = getParameter("username");\n  String product = getParameter("product");\n  log(username);\n  buy(username, product);\n}\n')),Object(o.b)("p",null,"Technically, the ",Object(o.b)("inlineCode",{parentName:"p"},"log")," method doesn't have any source, sink or propagation. We can use ",Object(o.b)("em",{parentName:"p"},"add features to arguments")," to add a feature ",Object(o.b)("inlineCode",{parentName:"p"},"was-logged")," on the flow from ",Object(o.b)("inlineCode",{parentName:"p"},'getParameter("username")')," to ",Object(o.b)("inlineCode",{parentName:"p"},"buy(username, product)"),". We could use the following JSON model for the ",Object(o.b)("inlineCode",{parentName:"p"},"log")," method:"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-json"}),'{\n  "add_features_to_arguments": [\n    {\n      "features": ["was-logged"],\n      "port": "Argument(0)"\n    }\n  ]\n}\n')),Object(o.b)("h4",{id:"via-type-features"},"Via-type Features"),Object(o.b)("p",null,Object(o.b)("em",{parentName:"p"},"Via-type")," features are used to keep track of the type of a callable\u2019s port seen at its callsites during taint flow analysis. They are specified in model generators within the \u201csources\u201d or \u201csinks\u201d field of a model with the \u201cvia_type_of\u201d field. It is mapped to a nonempty list of ports of the method for which we want to create via-type features."),Object(o.b)("p",null,"For example, if we were interested in the specific Activity subclasses with which the method below was called:"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),"\npublic void startActivityForResult (Intent intent, int requestCode);\n\n// At some callsite:\nActivitySubclass activitySubclassInstance;\nactivitySubclassInstance.startActivityForResult(intent, requestCode);\n\n")),Object(o.b)("p",null,"we could use the following JSON to specifiy a via-type feature that would materialize as ",Object(o.b)("inlineCode",{parentName:"p"},"via-type:ActivitySubclass"),":"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-json"}),'{\n "sinks": [\n   {\n     "port": "Argument(1)",\n     "kind": "SinkKind",\n     "via_type_of": ["Argument(0)"]\n   }\n ]\n}\n')),Object(o.b)("h3",{id:"modes"},"Modes"),Object(o.b)("p",null,"Modes are used to describe specific behaviors of methods. Available modes are:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"override-default"),": do not infer modes of methods using heuristics;"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"skip-analysis"),": skip the analysis of the method;"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"add-via-obscure-feature"),": add a feature/breadcrumb called ",Object(o.b)("inlineCode",{parentName:"li"},"via-obscure:<method>")," to sources flowing through this method;"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"taint-in-taint-out"),": propagate the taint on arguments to the return value and into the ",Object(o.b)("inlineCode",{parentName:"li"},"this")," parameter."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"no-join-virtual-overrides"),": do not consider all possible overrides when handling a virtual call to this method.")),Object(o.b)("h3",{id:"default-model"},"Default model"),Object(o.b)("p",null,"A default model is created for each method, except if it is provided by a model generator.\nThe default model has a set of heuristics:"),Object(o.b)("p",null,"If the method has no source code, the model is automatically marked with the following modes:\n",Object(o.b)("inlineCode",{parentName:"p"},"skip-analysis"),", ",Object(o.b)("inlineCode",{parentName:"p"},"add-via-obscure-feature"),", ",Object(o.b)("inlineCode",{parentName:"p"},"taint-in-taint-out"),"."),Object(o.b)("p",null,"If the method has more than 40 overrides, it is marked with the mode ",Object(o.b)("inlineCode",{parentName:"p"},"no-join-virtual-overrides"),"."),Object(o.b)("p",null,"Otherwise, the default model is empty (no sources/sinks/propagations)."),Object(o.b)("h2",{id:"generators"},"Generators"),Object(o.b)("p",null,"Mariana Trench allows for dynamic model specifications. This allows a user to specify models of methods before running the analysis. This is used to specify sources, sinks, propagation and modes."),Object(o.b)("p",null,"Model generators are specified in a generator configuration file, specified by the ",Object(o.b)("inlineCode",{parentName:"p"},"--generator-configuration-path")," parameter. By default, we use ",Object(o.b)("a",Object(i.a)({parentName:"p"},{href:"https://github.com/facebook/mariana-trench/blob/master/configuration/default_generator_config.json"}),Object(o.b)("inlineCode",{parentName:"a"},"default_generator_config.json")),"."),Object(o.b)("h3",{id:"example"},"Example"),Object(o.b)("p",null,"Examples of model generators are located in the ",Object(o.b)("a",Object(i.a)({parentName:"p"},{href:"https://github.com/facebook/mariana-trench/tree/master/configuration/model-generators"}),Object(o.b)("inlineCode",{parentName:"a"},"configuration/model-generators"))," directory."),Object(o.b)("p",null,"Below is an example of a JSON model generator:"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-json"}),'{\n  "model_generators": [\n      {\n        "find": "methods",\n        "where": [\n          { "constraint": "name", "pattern": "toString" }\n        ],\n        "model": {\n          "propagation": [\n            {\n              "input": "Argument(0)",\n              "output": "Return"\n            }\n          ]\n        }\n      },\n      {\n        "find": "methods",\n        "where": [\n          {\n            "constraint": "parent",\n            "inner": {\n              "constraint": "extends",\n              "inner": {\n                "constraint": "name", "pattern": "SandcastleCommand"\n              }\n            }\n          },\n          { "constraint": "name", "pattern": "Time" }\n        ],\n        "model": {\n          "sources": [\n            {\n              "kind": "Source",\n              "port": "Return"\n            }\n          ]\n        }\n      },\n      {\n        "find": "methods",\n        "where": [\n          { "constraint": "parent", "inner": { "constraint": "extends", "inner": { "constraint": "name", "pattern": "IEntWithPurposePolicy" }} },\n          { "constraint": "name", "pattern": "gen.*" },\n          { "constraint": "parameter", "idx": 0, "inner": { "constraint": "type", "kind": "extends", "class": "IViewerContext" } },\n          { "constraint": "return", "inner": { "constraint": "extends", "inner": { "constraint": "name", "pattern": "Ent" } } }\n        ],\n        "model": {\n          "modes": ["add-via-obscure-feature"],\n          "sinks": [\n            {\n              "kind": "Sink",\n              "port": "Argument(0)",\n              "features": ["via-gen"]\n            }\n          ]\n        }\n      }\n  ]\n}\n')),Object(o.b)("h3",{id:"specification"},"Specification"),Object(o.b)("p",null,"Each JSON file is a JSON object with a key ",Object(o.b)("inlineCode",{parentName:"p"},"model_generators"),' associated with a list of "rules".'),Object(o.b)("p",null,'Each "rule" defines a "filter" (which uses "constraints" to specify methods for which a "model" should be generated) and a "model". A rule has the following key/values:'),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"find"),": The type of thing to find. We only support ",Object(o.b)("inlineCode",{parentName:"li"},"methods"),";"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"where"),': A list of "constraints". All constraints ',Object(o.b)("strong",{parentName:"li"},"must be satisfied")," by a method in order to generate a model for such method. Constraints can have the following types (see below). Symbols in brackets define the type of the object matched against the constraint.",Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"parent")," ","[Method]",": Expects an extra property ",Object(o.b)("inlineCode",{parentName:"li"},"inner")," ","[Type]"," which contains a nested constraint to apply to the class holding the method;"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"name")," ","[Method|Type]",": Expects an extra property ",Object(o.b)("inlineCode",{parentName:"li"},"pattern")," which is a regex to fully match the name of the item;"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"signature")," ","[Method]",": Expects an extra property ",Object(o.b)("inlineCode",{parentName:"li"},"pattern")," which is a regex to fully match the full signature (class, method, argument types) of a method;"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"parameter")," ","[Method]",": Expects an extra properties ",Object(o.b)("inlineCode",{parentName:"li"},"idx")," and ",Object(o.b)("inlineCode",{parentName:"li"},"inner")," ","[Type]",", matches when the idx-th parameter of the function or method matches the nested constraint inner;"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"extends")," ","[Type]",": Expects an extra property ",Object(o.b)("inlineCode",{parentName:"li"},"inner")," ","[Type]"," which contains a nested constraint that must apply to one of the base classes or itself. The optional property ",Object(o.b)("inlineCode",{parentName:"li"},"includes_self")," is a boolean that tells whether the constraint must be applied on the type itself or not;"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"super")," ","[Type]",": Expects an extra property ",Object(o.b)("inlineCode",{parentName:"li"},"inner")," ","[Type]"," which contains a nested constraint that must apply on the direct superclass;"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"return")," ","[Method]",": Expects an extra property ",Object(o.b)("inlineCode",{parentName:"li"},"inner")," ","[Type]"," which contains a nested constraint to apply to the return of the method;"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"visibility")," ","[Method]",": Expects an extra property ",Object(o.b)("inlineCode",{parentName:"li"},"is")," which is either ",Object(o.b)("inlineCode",{parentName:"li"},"public"),", ",Object(o.b)("inlineCode",{parentName:"li"},"private")," or ",Object(o.b)("inlineCode",{parentName:"li"},"protected"),";"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"is_class")," ","[Type]",": Accepts an extra property ",Object(o.b)("inlineCode",{parentName:"li"},"value")," which is either ",Object(o.b)("inlineCode",{parentName:"li"},"true")," or ",Object(o.b)("inlineCode",{parentName:"li"},"false"),". By default, ",Object(o.b)("inlineCode",{parentName:"li"},"value")," is considered ",Object(o.b)("inlineCode",{parentName:"li"},"true"),";"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"is_interface")," ","[Type]",": Accepts an extra property ",Object(o.b)("inlineCode",{parentName:"li"},"value")," which is either ",Object(o.b)("inlineCode",{parentName:"li"},"true")," or ",Object(o.b)("inlineCode",{parentName:"li"},"false"),". By default, ",Object(o.b)("inlineCode",{parentName:"li"},"value")," is considered ",Object(o.b)("inlineCode",{parentName:"li"},"true"),";"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"is_static")," ","[Method]",": Accepts an extra property ",Object(o.b)("inlineCode",{parentName:"li"},"value")," which is either ",Object(o.b)("inlineCode",{parentName:"li"},"true")," or ",Object(o.b)("inlineCode",{parentName:"li"},"false"),". By default, ",Object(o.b)("inlineCode",{parentName:"li"},"value")," is considered ",Object(o.b)("inlineCode",{parentName:"li"},"true"),";"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"is_constructor")," ","[Method]",": Accepts an extra property ",Object(o.b)("inlineCode",{parentName:"li"},"value")," which is either ",Object(o.b)("inlineCode",{parentName:"li"},"true")," or ",Object(o.b)("inlineCode",{parentName:"li"},"false"),". By default, ",Object(o.b)("inlineCode",{parentName:"li"},"value")," is considered ",Object(o.b)("inlineCode",{parentName:"li"},"true"),";"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"is_native")," ","[Method]",": Accepts an extra property ",Object(o.b)("inlineCode",{parentName:"li"},"value")," which is either ",Object(o.b)("inlineCode",{parentName:"li"},"true")," or ",Object(o.b)("inlineCode",{parentName:"li"},"false"),". By default, ",Object(o.b)("inlineCode",{parentName:"li"},"value")," is considered ",Object(o.b)("inlineCode",{parentName:"li"},"true"),";"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"has_code")," ","[Method]",": Accepts an extra property ",Object(o.b)("inlineCode",{parentName:"li"},"value")," which is either ",Object(o.b)("inlineCode",{parentName:"li"},"true")," or ",Object(o.b)("inlineCode",{parentName:"li"},"false"),". By default, ",Object(o.b)("inlineCode",{parentName:"li"},"value")," is considered ",Object(o.b)("inlineCode",{parentName:"li"},"true"),";"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"has_annotation")," ","[Method|Type]",": Expects an extra property ",Object(o.b)("inlineCode",{parentName:"li"},"type")," and an optional property ",Object(o.b)("inlineCode",{parentName:"li"},"pattern"),", respectively a string and a regex fully matching the value of the annotation."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"number_parameters")," ","[Method]",": Expects an extra property ",Object(o.b)("inlineCode",{parentName:"li"},"inner")," ","[Integer]"," which contains a nested constraint to apply to the number of parameters (counting the implicit ",Object(o.b)("inlineCode",{parentName:"li"},"this")," parameter);"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"number_overrides")," ","[Method]",": Expects an extra property ",Object(o.b)("inlineCode",{parentName:"li"},"inner")," ","[Integer]"," which contains a nested constraint to apply on the number of method overrides."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"< | <= | == | > | >= | !=")," ","[Integer]",": Expects an extra property ",Object(o.b)("inlineCode",{parentName:"li"},"value")," which contains an integer that the input integer is compared with. The input is the left hand side."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"all_of")," ","[Any]",": Expects an extra property ",Object(o.b)("inlineCode",{parentName:"li"},"inners")," ","[Any]"," which is an array holding nested constraints which must all apply;"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"any_of")," ","[Any]",": Expects an extra property ",Object(o.b)("inlineCode",{parentName:"li"},"inners")," ","[Any]"," which is an array holding nested constraints where one of them must apply;"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"not")," ","[Any]",": Expects an extra property ",Object(o.b)("inlineCode",{parentName:"li"},"inner")," ","[Any]"," which contains a nested constraint that should not apply."))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"model"),": A model, describing sources/sinks/propagations/etc.",Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"sources"),"*: A list of sources, i.e a source flowing out of the method via return value or flowing in via an argument. A source has the following key/values:",Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"kind"),": The source name;"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"port"),"**: The source access path (e.g, ",Object(o.b)("inlineCode",{parentName:"li"},'"Return"')," or ",Object(o.b)("inlineCode",{parentName:"li"},'"Argument(1)"'),");"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"features"),"*: A list of features/breadcrumbs names;"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"via_type_of"),"*: A list of ports;"))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"sinks"),"*: A list of sinks, i.e describing that a parameter of the method flows into a sink. A sink has the following key/values:",Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"kind"),": The sink name;"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"port"),": The sink access path (e.g, ",Object(o.b)("inlineCode",{parentName:"li"},'"Return"')," or ",Object(o.b)("inlineCode",{parentName:"li"},'"Argument(1)"'),");"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"features"),"*:  A list of features/breadcrumbs names;"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"via_type_of"),"*: A list of ports;"))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"propagation"),"*: A list of propagations (also called passthrough) that describe whether a taint on a parameter should result in a taint on the return value or another parameter. A propagation has the following key/values:",Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"input"),": The input access path (e.g, ",Object(o.b)("inlineCode",{parentName:"li"},'"Argument(1)"'),");"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"output"),": The output access path (e.g, ",Object(o.b)("inlineCode",{parentName:"li"},'"Return"')," or ",Object(o.b)("inlineCode",{parentName:"li"},'"Argument(2)"'),");"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"features"),"*: A list of features/breadcrumbs names;"))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"attach_to_sources"),"*: A list of attach-to-sources that describe that all sources flowing out of the method on the given parameter or return value must have the given features. An attach-to-source has the following key/values:",Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"port"),": The access path root (e.g, ",Object(o.b)("inlineCode",{parentName:"li"},'"Return"')," or ",Object(o.b)("inlineCode",{parentName:"li"},'"Argument(1)"'),");"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"features"),": A list of features/breadcrumb names;"))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"attach_to_sinks"),"*: A list of attach-to-sinks that describe that all sources flowing in the method on the given parameter must have the given features. An attach-to-sink has the following key/values:",Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"port"),": The access path root (e.g, ",Object(o.b)("inlineCode",{parentName:"li"},'"Argument(1)"'),");"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"features"),": A list of features/breadcrumb names;"))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"attach_to_propagations"),"*: A list of attach-to-propagations that describe that inferred propagations of sources flowing in or out of a given parameter or return value  must have the given features. An attach-to-propagation has the following key/values:",Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"port"),": The access path root (e.g, ",Object(o.b)("inlineCode",{parentName:"li"},'"Return"')," or ",Object(o.b)("inlineCode",{parentName:"li"},'"Argument(1)"'),");"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"features"),": A list of features/breadcrumb names;"))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"add_features_to_parameters"),"*: A list of add-features-to-parameters that describe that flows that might flow on the given parameter must have the given features. An add-features-to-parameter has the following key/values:",Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"port"),": The access path root (e.g, ",Object(o.b)("inlineCode",{parentName:"li"},'"Argument(1)"'),");"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"features"),": A list of features/breadcrumb names;"))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"modes"),"*: A list of mode names that describe specific behaviors of a method;"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"for_all_parameters"),": Generate sources/sinks/propagations/attach",Object(o.b)("em",{parentName:"li"},"to"),"* for all parameters of a method that satisfy some constraints. It accepts the following key/values:",Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"variable"),": A symbolic name for the parameter;"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"where"),": An optional list of constraints on the type of the parameter;"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"sources | sinks | propagation"),': Same as under "model", but we accept the variable name as a parameter number.'))))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"verbosity"),"*: A logging level, to help debugging. 1 is the most verbose, 5 is the least. The default verbosity level is 5.")),Object(o.b)("p",null,"In the above bullets,"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"*")," denotes optional key/value."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"**")," denotes optional key/value. Default is ",Object(o.b)("inlineCode",{parentName:"li"},'"Return"'),".")),Object(o.b)("p",null,"Note, the implicit ",Object(o.b)("inlineCode",{parentName:"p"},"this")," parameter for methods has the parameter number 0."),Object(o.b)("h3",{id:"development"},"Development"),Object(o.b)("h4",{id:"when-sources-or-sinks-dont-appear-in-results"},"When Sources or Sinks don't appear in Results"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"This could be because your model generator did not find any method matching your query. You can use the ",Object(o.b)("inlineCode",{parentName:"p"},'"verbosity": 1')," option in your model generator to check if it matched any method. For instance:"),Object(o.b)("pre",{parentName:"li"},Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-json"}),'{\n  "model_generators":. [\n    {\n      "find": "methods",\n      "where": /* ... */,\n      "model": {\n        /* ... */\n      },\n      "verbosity": 1\n    }\n  ]\n}\n')),Object(o.b)("p",{parentName:"li"},"When running mariana trench, this should print:"),Object(o.b)("pre",{parentName:"li"},Object(o.b)("code",Object(i.a)({parentName:"pre"},{}),"INFO Method `...` satisfies all constraints in json model generator ...\n"))),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Make sure that your model generator is actually running. You can use the ",Object(o.b)("inlineCode",{parentName:"p"},"--verbosity 2")," option to check that. Make sure your model generator is specified in ",Object(o.b)("inlineCode",{parentName:"p"},"shim/resources/default_generator_config.json"),".")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"You can also check the output models.\nUse ",Object(o.b)("inlineCode",{parentName:"p"},"grep SourceKind models@*")," to see if your source or sink kind exists.\nUse ",Object(o.b)("inlineCode",{parentName:"p"},"grep 'Lcom/example/<class-name>;.<method-name>:' models@*")," to see if a given method exists in the app."))),Object(o.b)(b,{mdxType:"FbModels"}))}d.isMDXComponent=!0}}]);